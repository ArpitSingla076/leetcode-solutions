--- M-1 (check inorder traversal is sorted or not) ---  (Brute force)

class Solution {
    public void inorder( ArrayList<Integer> result,TreeNode root) {
        if(root==null)return;
        inorder(result,root.left);
        result.add(root.val);
        inorder(result,root.right);
    }

    public boolean isValidBST(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        inorder(result,root);
        for(int i=1;i<result.size();i++) {
            if(result.get(i)<=result.get(i-1)) {
                return false;
            }
        }
        return true;
    }
}


--- M-2 (using concept of Min and Max) --- (Optimal Method)

check if max value in left subtree < node
and min value in right subtree > node

class Solution {
    public boolean helper(TreeNode root,long minVal,long maxVal) {
        if(root==null)return true;
        if(root.val>=maxVal || root.val<=minVal) return false;
        return helper(root.left,minVal,root.val) && helper(root.right,root.val,maxVal);
    }
    public boolean isValidBST(TreeNode root) {
        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
}
